<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Quick Memo</title>
    <style>
        :root {
            --bg-color: #f9f9f9; /* メモ帳っぽい紙の色 */
            --text-color: #333;
            --header-bg: #ffffff;
            --border-color: #eee;
            --accent-color: #007bff;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            height: 100vh;
            display: flex; flex-direction: column;
            overflow: hidden;
        }

        /* ヘッダー */
        header {
            background-color: var(--header-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 10px 15px;
            display: flex; justify-content: space-between; align-items: center;
            height: 50px; box-sizing: border-box;
            box-shadow: 0 2px 4px rgba(0,0,0,0.02);
        }

        h1 {
            font-size: 1.1rem; margin: 0; color: #555; font-weight: 600;
            cursor: pointer; /* 時計をクリックで履歴表示 */
        }

        /* ステルスボタン */
        .stealth-btn {
            background: none; border: none; cursor: pointer; padding: 8px;
            display: flex; align-items: center; justify-content: center;
            outline: none; -webkit-tap-highlight-color: transparent;
        }
        .icon { width: 24px; height: 24px; fill: #999; transition: fill 0.3s; }
        
        /* 録音中は青く点滅 */
        body.recording .icon { fill: var(--accent-color); animation: breathe 2s infinite; }
        @keyframes breathe { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        /* メモエリア */
        textarea {
            flex: 1; width: 100%; border: none; padding: 20px;
            font-size: 16px; /* iOSでズームしないサイズ */
            line-height: 1.6; resize: none; outline: none;
            box-sizing: border-box; background-color: transparent;
        }

        /* 履歴ドロワー（隠しメニュー） */
        #history-drawer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 100;
            display: none; align-items: flex-end;
        }
        #history-content {
            width: 100%; background: white; border-radius: 20px 20px 0 0;
            max-height: 60%; overflow-y: auto; padding: 20px; box-sizing: border-box;
        }
        .history-item {
            padding: 15px 0; border-bottom: 1px solid #eee; display: flex; justify-content: space-between;
        }
        .history-date { font-size: 0.8rem; color: #999; }
        .history-memo { font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        
        .status-bar {
            padding: 5px 15px; font-size: 0.7rem; color: #ccc; text-align: right; background: #fff;
        }

        #error-log { display: none; color: red; font-size: 0.7rem; text-align: center; }
    </style>
</head>
<body>

    <header>
        <h1 id="clock" onclick="toggleHistory()">Memo</h1>
        <button class="stealth-btn" id="mainBtn" onclick="handleBtnClick()">
            <svg class="icon" viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2zM17 21v-8H7v8h10zM7 7v4h10V7H7z"/></svg>
        </button>
    </header>

    <textarea id="memo-area" placeholder="ここにメモを入力..." oninput="saveMemoLocal()"></textarea>

    <div class="status-bar" id="status-text">Ready</div>
    <div id="error-log"></div>

    <div id="history-drawer" onclick="toggleHistory()">
        <div id="history-content" onclick="event.stopPropagation()">
            <h3 style="margin-top:0; color:#333;">Session History</h3>
            <div id="history-list"></div>
            <button onclick="toggleHistory()" style="width:100%; padding:15px; margin-top:10px; border:none; background:#eee; border-radius:10px;">Close</button>
        </div>
    </div>

    <script>
        // === 設定 ===
        const CONFIG = { sampleRate: 16000, nFft: 400, hopLength: 160, nMels: 80 };

        let audioCtx, processor, source;
        let isRecording = false;
        let melFilters = null;
        let melFrames = [];
        let sampleBuffer = [];
        let cosTable, sinTable;
        let intervalId;
        
        // UI
        const statusEl = document.getElementById('status-text');
        const memoEl = document.getElementById('memo-area');
        const clockEl = document.getElementById('clock');
        const historyListEl = document.getElementById('history-list');

        // 時計
        setInterval(() => {
            const now = new Date();
            clockEl.innerText = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }, 1000);

        // エラー
        window.onerror = (msg) => {
            document.getElementById('error-log').style.display = 'block';
            document.getElementById('error-log').innerText = `Err: ${msg}`;
        };

        // 初期化
        window.onload = async () => {
            // ローカル保存したメモを復元
            if(localStorage.getItem('current_memo')) {
                memoEl.value = localStorage.getItem('current_memo');
            }

            precomputeDFT();
            try {
                const res = await fetch('mel_filters.json');
                if(!res.ok) throw new Error("Net Err");
                const data = await res.json();
                melFilters = data.filters;
            } catch(e) { statusEl.innerText = "Sync Error"; }
        };

        // メモのローカル保存（入力するたびに保存）
        function saveMemoLocal() {
            localStorage.setItem('current_memo', memoEl.value);
        }

        // 履歴画面トグル
        function toggleHistory() {
            const el = document.getElementById('history-drawer');
            el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
        }

        // 履歴追加
        function addHistory(filename, memo) {
            const item = document.createElement('div');
            item.className = 'history-item';
            const time = new Date().toLocaleTimeString();
            item.innerHTML = `
                <div>
                    <div style="font-weight:bold; font-size:0.9rem;">${filename}</div>
                    <div class="history-date">${time}</div>
                </div>
                <div class="history-memo">${memo}</div>
            `;
            historyListEl.prepend(item);
        }

        // ボタン操作
        async function handleBtnClick() {
            if(!melFilters) return;
            if(!isRecording) await startRecording();
            else stopRecording();
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext({ sampleRate: CONFIG.sampleRate });
                if(audioCtx.state === 'suspended') await audioCtx.resume();

                source = audioCtx.createMediaStreamSource(stream);
                processor = audioCtx.createScriptProcessor(4096, 1, 1);
                source.connect(processor);
                processor.connect(audioCtx.destination);

                melFrames = [];
                sampleBuffer = [];
                isRecording = true;
                
                document.body.classList.add('recording');
                statusEl.innerText = "Syncing...";
                
                processor.onaudioprocess = (e) => {
                    if(!isRecording) return;
                    processAudioChunk(e.inputBuffer.getChannelData(0));
                };

                intervalId = setInterval(() => {
                    const kb = Math.round((melFrames.length * 80) / 1024);
                    statusEl.innerText = `Synced: ${kb} KB`; 
                }, 1000);

            } catch(e) { alert("Err: " + e.message); }
        }

        function stopRecording() {
            isRecording = false;
            clearInterval(intervalId);
            
            if(source) { source.disconnect(); source = null; }
            if(processor) { processor.disconnect(); processor = null; }
            if(audioCtx) { audioCtx.close(); audioCtx = null; }

            document.body.classList.remove('recording');
            statusEl.innerText = "Saved";

            if(melFrames.length > 0) saveBinaryFileV2();
        }

        // 信号処理
        function precomputeDFT() {
            const N = CONFIG.nFft;
            cosTable = new Float32Array((N/2 + 1) * N);
            sinTable = new Float32Array((N/2 + 1) * N);
            for(let k=0; k<=N/2; k++) {
                for(let t=0; t<N; t++) {
                    const angle = (2 * Math.PI * k * t) / N;
                    const idx = k*N + t;
                    cosTable[idx] = Math.cos(angle);
                    sinTable[idx] = Math.sin(angle);
                }
            }
        }

        function processAudioChunk(inputData) {
            for(let i=0; i<inputData.length; i++) {
                let val = inputData[i];
                if(Number.isNaN(val)) val = 0;
                sampleBuffer.push(val);
            }
            while(sampleBuffer.length >= CONFIG.nFft) {
                const frame = sampleBuffer.slice(0, CONFIG.nFft);
                sampleBuffer.splice(0, CONFIG.hopLength);
                computeMel(frame);
            }
        }

        function computeMel(waveform) {
            const N = CONFIG.nFft;
            const windowed = new Float32Array(N);
            for(let i=0; i<N; i++) {
                windowed[i] = waveform[i] * (0.5 * (1 - Math.cos((2 * Math.PI * i) / N)));
            }
            const magnitudes = new Float32Array(N/2 + 1);
            for(let k=0; k<=N/2; k++) {
                let re = 0, im = 0;
                const offset = k * N;
                for(let t=0; t<N; t++) {
                    re += windowed[t] * cosTable[offset + t];
                    im -= windowed[t] * sinTable[offset + t];
                }
                magnitudes[k] = re*re + im*im;
            }
            const melFrame = [];
            for(let m=0; m<CONFIG.nMels; m++) {
                let sum = 0;
                for(let k=0; k<magnitudes.length; k++) {
                    sum += melFilters[m][k] * magnitudes[k];
                }
                if(Number.isNaN(sum)) sum = 0;
                melFrame.push(Math.log10(Math.max(sum, 1e-10)));
            }
            melFrames.push(melFrame);
        }

        // === バイナリ保存 V2 (メモ埋め込み対応) ===
        function saveBinaryFileV2() {
            // 1. Min/Max 計算
            let minVal = Infinity, maxVal = -Infinity;
            for(let i=0; i<melFrames.length; i++) {
                for(let j=0; j<CONFIG.nMels; j++) {
                    const v = melFrames[i][j];
                    if(v < minVal) minVal = v;
                    if(v > maxVal) maxVal = v;
                }
            }
            if (minVal === Infinity) { minVal = -10.0; maxVal = 2.0; }
            if (maxVal === minVal) maxVal = minVal + 1.0;

            // 2. メモテキストのエンコード
            const memoText = memoEl.value;
            const encoder = new TextEncoder();
            const memoBytes = encoder.encode(memoText);
            const memoLen = memoBytes.length;

            // 3. バッファサイズ計算
            // Header(24) + Body(Frames*80) + MemoLen(4) + MemoBytes
            const headerSize = 24;
            const bodySize = melFrames.length * CONFIG.nMels;
            const bufferSize = headerSize + bodySize + 4 + memoLen;
            
            const buffer = new ArrayBuffer(bufferSize);
            const view = new DataView(buffer);
            
            // Header
            view.setUint8(0, 86); view.setUint8(1, 76); view.setUint8(2, 79); view.setUint8(3, 71); // "VLOG"
            view.setUint32(4, 2, true); // Version 2 (Memo Support)
            view.setUint32(8, melFrames.length, true);
            view.setUint32(12, CONFIG.nMels, true);
            view.setFloat32(16, minVal, true);
            view.setFloat32(20, maxVal, true);

            // Body (Quantized Audio)
            const u8View = new Uint8Array(buffer);
            let ptr = headerSize;
            for(let i=0; i<melFrames.length; i++) {
                for(let j=0; j<CONFIG.nMels; j++) {
                    const normalized = (melFrames[i][j] - minVal) / (maxVal - minVal);
                    let byteVal = Math.floor(normalized * 255);
                    if(byteVal < 0) byteVal = 0; if(byteVal > 255) byteVal = 255;
                    u8View[ptr++] = byteVal;
                }
            }

            // Footer (Memo)
            // ポインタ位置は headerSize + bodySize
            view.setUint32(ptr, memoLen, true);
            ptr += 4;
            
            // メモデータを書き込み
            for(let i=0; i<memoLen; i++) {
                u8View[ptr++] = memoBytes[i];
            }

            // ダウンロード
            const blob = new Blob([buffer], { type: "application/octet-stream" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `voice_log_${timestamp}.bin`;
            a.download = filename;
            a.click();

            // 履歴に追加
            addHistory(filename, memoText);
        }
    </script>
</body>
</html>
