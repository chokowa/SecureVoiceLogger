<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Memo</title>
    <style>
        :root { --bg-color: #f9f9f9; --text-color: #333; --header-bg: #ffffff; --border-color: #ddd; --accent-color: #007bff; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 0; height: 100vh; height: 100dvh; display: flex; flex-direction: column; overflow: hidden; }
        
        header { 
            background-color: var(--header-bg); border-bottom: 1px solid var(--border-color); 
            position: sticky; top: 0; z-index: 9999; 
            padding-top: max(20px, env(safe-area-inset-top)); 
            padding-bottom: 10px; padding-left: 15px; padding-right: 15px; 
            display: flex; justify-content: space-between; align-items: center; 
            flex-shrink: 0; min-height: 44px; box-sizing: content-box; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
        }

        h1 { font-size: 1.1rem; margin: 0; color: #555; font-weight: 600; cursor: pointer; user-select: none; }
        
        .header-controls { display: flex; gap: 15px; }

        .btn {
            background: none; border: none; cursor: pointer; padding: 8px;
            display: flex; align-items: center; justify-content: center;
            outline: none; -webkit-tap-highlight-color: transparent; width: 44px; height: 44px; 
        }
        .icon { width: 28px; height: 28px; fill: #888; transition: fill 0.3s; }
        
        /* 録音ボタンのスタイル */
        body.recording .record-icon { fill: var(--accent-color); animation: breathe 2s infinite; }
        @keyframes breathe { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
        
        /* ペンボタンのスタイル */
        .pen-icon { width: 24px; height: 24px; }

        textarea { flex: 1; width: 100%; border: none; padding: 20px; font-size: 16px; line-height: 1.6; resize: none; outline: none; box-sizing: border-box; background-color: transparent; -webkit-overflow-scrolling: touch; }
        
        #history-drawer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: none; align-items: flex-end; backdrop-filter: blur(2px); }
        #history-content { width: 100%; background: white; border-radius: 20px 20px 0 0; max-height: 70%; overflow-y: auto; padding: 20px; box-sizing: border-box; box-shadow: 0 -5px 20px rgba(0,0,0,0.2); padding-bottom: max(20px, env(safe-area-inset-bottom)); }
        
        .history-item { padding: 15px 0; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; cursor: pointer; }
        .history-item:active { background-color: #f0f0f0; }
        .history-date { font-size: 0.8rem; color: #999; }
        .history-memo { font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; color: #333; }
        
        .status-bar { padding: 8px 15px; font-size: 0.75rem; color: #aaa; text-align: right; background: #fff; border-top: 1px solid #eee; padding-bottom: max(8px, env(safe-area-inset-bottom)); flex-shrink: 0; }
        #error-log { display: none; color: red; font-size: 0.7rem; text-align: center; }
    </style>
</head>
<body>
    <header>
        <h1 id="clock" onclick="toggleHistory()">Memo</h1>
        
        <div class="header-controls">
            <button class="btn" id="updateBtn" onclick="updateMemoOnly()">
                <svg class="icon pen-icon" viewBox="0 0 24 24">
                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                </svg>
            </button>

            <button class="btn" id="mainBtn" onclick="handleBtnClick()">
                <svg class="icon record-icon" viewBox="0 0 24 24">
                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2zM17 21v-8H7v8h10zM7 7v4h10V7H7z"/>
                </svg>
            </button>
        </div>
    </header>
    
    <textarea id="memo-area" placeholder="ここにメモを入力..." oninput="saveMemoLocal()"></textarea>
    
    <div class="status-bar" id="status-text">Ready</div>
    <div id="error-log"></div>
    
    <div id="history-drawer" onclick="toggleHistory()">
        <div id="history-content" onclick="event.stopPropagation()">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h3 style="margin:0; color:#333;">History</h3>
                <button onclick="toggleHistory()" style="border:none; background:none; font-size:1.5rem; padding:0 10px;">✕</button>
            </div>
            <div id="history-list"><div style="color:#ccc; text-align:center; padding:20px;">No records yet</div></div>
        </div>
    </div>
    
    <script>
        const CONFIG = { sampleRate: 16000 };
        let audioCtx, processor, source;
        let isRecording = false;
        let pcmChunks = []; // 現在のセッションの音声データ
        let intervalId;

        const statusEl = document.getElementById('status-text');
        const memoEl = document.getElementById('memo-area');
        const clockEl = document.getElementById('clock');
        const historyListEl = document.getElementById('history-list');

        setInterval(() => {
            const now = new Date();
            clockEl.innerText = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }, 1000);

        window.onerror = (msg) => {
            document.getElementById('error-log').style.display = 'block';
            document.getElementById('error-log').innerText = `Err: ${msg}`;
        };

        window.onload = () => {
            if(localStorage.getItem('current_memo')) memoEl.value = localStorage.getItem('current_memo');
            loadHistoryUI();
        };

        function saveMemoLocal() { localStorage.setItem('current_memo', memoEl.value); }
        
        function toggleHistory() {
            const el = document.getElementById('history-drawer');
            el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
        }

        function getHistory() { try { return JSON.parse(localStorage.getItem('voice_log_history') || '[]'); } catch { return []; } }
        
        function saveHistoryItem(filename, memo) {
            const history = getHistory();
            const time = new Date().toLocaleTimeString();
            history.unshift({ filename, memo, time }); 
            if(history.length > 20) history.pop();
            localStorage.setItem('voice_log_history', JSON.stringify(history));
            loadHistoryUI();
        }

        // 履歴UI構築 (クリックイベント追加)
        function loadHistoryUI() {
            const history = getHistory();
            if(history.length === 0) return;
            historyListEl.innerHTML = '';
            history.forEach(item => {
                const div = document.createElement('div');
                div.className = 'history-item';
                // 安全にクリックイベントを設定
                div.onclick = () => loadMemoFromHistory(item.memo);
                
                div.innerHTML = `
                    <div style="pointer-events:none;">
                        <div style="font-weight:bold; font-size:0.9rem;">${item.filename}</div>
                        <div class="history-date">${item.time}</div>
                    </div>
                    <div class="history-memo" style="margin-left:10px; pointer-events:none;">${item.memo || '(No Memo)'}</div>
                `;
                historyListEl.appendChild(div);
            });
        }

        // 履歴からメモを呼び出す
        function loadMemoFromHistory(memoText) {
            if (confirm("メモを読み込みますか？\n(現在の入力内容は上書きされます)")) {
                memoEl.value = memoText || "";
                saveMemoLocal();
                toggleHistory(); // ドロワーを閉じる
            }
        }

        async function handleBtnClick() {
            if(!isRecording) await startRecording();
            else stopRecording();
        }

        // メモのみ更新 (ペンボタン)
        function updateMemoOnly() {
            if (isRecording) {
                alert("録音中は操作できません。停止してから保存してください。");
                return;
            }

            const memoText = memoEl.value;
            
            // ケース1: 直前の音声データがメモリにある場合 -> .bin を再作成
            if (pcmChunks.length > 0) {
                if(confirm("直前の音声データと合わせて、メモを更新保存しますか？")) {
                    saveRawContainer(true); // true = update mode (skip history add optional)
                }
            } 
            // ケース2: 音声データがない (リロード後や過去履歴) -> .txt で保存
            else {
                if(confirm("音声データがメモリにありません(リロード等)。\nテキストファイルとして保存しますか？")) {
                    saveTextOnly(memoText);
                }
            }
        }

        function saveTextOnly(text) {
            const blob = new Blob([text], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            a.download = `memo_${timestamp}.txt`;
            a.click();
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext({ sampleRate: CONFIG.sampleRate });
                if(audioCtx.state === 'suspended') await audioCtx.resume();

                source = audioCtx.createMediaStreamSource(stream);
                processor = audioCtx.createScriptProcessor(4096, 1, 1);
                
                source.connect(processor);
                processor.connect(audioCtx.destination);

                pcmChunks = []; // リセット
                isRecording = true;
                
                document.body.classList.add('recording');
                statusEl.innerText = "Syncing...";
                
                processor.onaudioprocess = (e) => {
                    if(!isRecording) return;
                    const input = e.inputBuffer.getChannelData(0);
                    encodeMuLaw(input);
                };

                intervalId = setInterval(() => {
                    const kb = Math.round((pcmChunks.length * 4096) / 1024);
                    statusEl.innerText = `Sync: ${kb} KB`; 
                }, 1000);

            } catch(e) { alert("Err: " + e.message); }
        }

        function stopRecording() {
            isRecording = false;
            clearInterval(intervalId);
            if(source) { source.disconnect(); source = null; }
            if(processor) { processor.disconnect(); processor = null; }
            if(audioCtx) { audioCtx.close(); audioCtx = null; }

            document.body.classList.remove('recording');
            statusEl.innerText = "Saved";

            if(pcmChunks.length > 0) saveRawContainer();
        }

        function encodeMuLaw(input) {
            const mu = 255;
            const chunk = new Uint8Array(input.length);
            for(let i=0; i<input.length; i++) {
                let sample = input[i];
                if(sample < -1) sample = -1;
                if(sample > 1) sample = 1;
                const sign = sample < 0 ? -1 : 1;
                const abs = Math.abs(sample);
                const encoded = Math.sign(sample) * (Math.log(1 + mu * abs) / Math.log(1 + mu));
                let uint8 = Math.floor((encoded + 1) / 2 * 255);
                if(uint8 < 0) uint8 = 0; 
                if(uint8 > 255) uint8 = 255;
                chunk[i] = uint8;
            }
            pcmChunks.push(chunk);
        }

        function saveRawContainer(isUpdate = false) {
            const memoText = memoEl.value;
            const encoder = new TextEncoder();
            const memoBytes = encoder.encode(memoText);
            const memoLen = memoBytes.length;

            const totalSamples = pcmChunks.length * 4096;
            const headerSize = 20; 
            const bufferSize = headerSize + totalSamples + memoLen;
            
            const buffer = new ArrayBuffer(bufferSize);
            const view = new DataView(buffer);
            
            view.setUint8(0, 86); view.setUint8(1, 76); view.setUint8(2, 79); view.setUint8(3, 71); // "VLOG"
            view.setUint32(4, 6, true);
            view.setUint32(8, totalSamples, true);
            view.setUint32(12, 16000, true);
            view.setUint32(16, memoLen, true);

            const u8View = new Uint8Array(buffer);
            let ptr = headerSize;
            
            for(let i=0; i<pcmChunks.length; i++) {
                u8View.set(pcmChunks[i], ptr);
                ptr += pcmChunks[i].length;
            }

            u8View.set(memoBytes, ptr);

            const blob = new Blob([buffer], { type: "application/octet-stream" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, 19);
            
            // ファイル名を偽装: sys_data_...
            const filename = `sys_data_${timestamp}.bin`;
            
            a.download = filename;
            a.click();

            if (!isUpdate) {
                saveHistoryItem(filename, memoText);
            }
        }
    </script>
</body>
</html>
